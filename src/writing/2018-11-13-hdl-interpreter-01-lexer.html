---
title: "An HDL Interpreter with Reason, Part 1: The Lexer"
custom_css: highlight.css
---

<p>A couple of weeks ago, I started the fantastic Coursera course <a href="https://www.coursera.org/learn/build-a-computer">From Nand to Tetris</a> where one implements a full virtual computer starting from the smallest building block, the <abbr title="Not and"><i>Nand</i></abbr> gate. The course is very project-centered and uses a small declarative language called <abbr title="Hardware Description Language">HDL</abbr> to implement the various hardware pieces in software.</p>

<p>The course instructors even provide a hardware simulator where you can run, test, and visually simulate your HDL scripts. That works all fine and dandy, however, I have some issues with that approach. For example, there is no way to edit your HDL scripts right inside the hardware simulator, tests are not re-run on changes in your HDL code which makes testing quite cumbersome, and the Java UI is not really pleasant on the eyes.</p>

<img src="/assets/images/hdl-interpreter/hardware_simulator.png" alt="The GUI of the Hardware Simulator">

<p>I immediately thought about creating an in-browser IDE for HDL scripts with a simple UI, auto-testing, and nothing to download or install. Before I could think about the feature set, though, I needed an <i>interpreter</i> for HDL. And so my quest begins.</p>

<h2>Initial Considerations</h2>

<p>In a sense an interpreter <i>implements</i> a language, not unlike a compiler. However, compilation in the traditional sense is a two-stage process where a high-level language is first transformed into machine code for the target machine and then executed by this machine to produce results. An interpreter, on the other hand, is a program that takes code in a source language and executes/evaluates it in a <i>certain environment</i>. This environment holds the rules for evaluating expressions of our source language and also a lookup table for identifiers.</p>

<p>Now that I knew what I wanted to make, I had to think about the right tools. I wanted the HDL interpreter to run inside the browser so JavaScript is a sensible implementation language. There are a couple of great examples of interpreters/compilers made with JavaScript out there:</p>

<ul>
  <li>Mariko Kosaka’s <a href="https://medium.com/@kosamari/how-to-be-a-compiler-make-a-compiler-with-javascript-4a8a13d473b4">How to be* a compiler — make a compiler with JavaScript</a> </li>
  <li>Minko Gechev’s <a href="https://blog.mgechev.com/2017/09/16/developing-simple-interpreter-transpiler-compiler-tutorial/">Implementing a Simple Compiler on 25 Lines of JavaScript</a></li>
  <li>Jamie Kyle’s <a href="https://github.com/jamiebuilds/the-super-tiny-compiler">The Super Tiny Compiler</a></li>
</ul>

<p>Each one of these projects is marvelous and I highly recommend checking them out, but using JavaScript as the implementation language did not feel right to me. I wanted to write code that clearly describes the concepts and steps an interpreter is made of and with JavaScript I always felt they are getting lost at some point.</p>

<p>And then it hit me! In my very first lecture in college <i>Programming – An Introduction to Computer Science</i> we built an interpreter with SML for a very simple programming language called <i>F</i>. And it was a thing of beauty. We started thinking about the syntax and semantics of F, then assembled grammars and inference rules on paper, and finally poured everything into easy-to-read SML code.</p>

<p>I wanted the same for my HDL interpreter on top of being runnable inside the browser. While there is the <a href="http://www.smlserver.org/smltojs/">SMLtoJs</a> project, I opted for a combo with a much larger community: <a href="https://reasonml.github.io/">Reason/OCaml</a> with <a href="https://bucklescript.github.io/">Bucklescript</a>.</p>

<h2>The Phases of an Interpreter</h2>

<p>Interpreter design and the underlying theory of programming languages is well understood in computer science and comprises the following steps:</p>

<ol>
  <li>The <b>lexical analysis</b> or <b>tokenization</b> takes a piece of code in our source language and turns its characters and symbols into a stream of words that are valid according to the source language’s grammar. This grammar is therefore a recipe for the language’s <i>concrete syntax</i> and those words are also called <b>tokens</b>.</li>
  <li>The <b>syntactical analysis</b> or <b>parsing</b> is in charge of turning this list of tokens into a tree form which complies with the languags’s grammar for its <i>abstract</i> syntax. The resulting tree is also called <b>Abstract Syntax Tree</b>, or <i>AST</i>.</li>
  <li>The final step is called <b>evaluation</b> which takes the AST and evaluates it according to the language’s <i>dynamic semantics</i> inside an environment that maps identifiers to values.</li>
</ol>

<aside>
  <p>Dynamic semantics is concerned with evaluating values of expressions. Its buddy <i>static semantics</i> describes the <i>type</i> (and other constraints of validity) of expressions. Usually we would have another step between parsing and evaluation that checks whether the code adheres to the static semantics. This step is called <b>semantic analysis</b>. Since HDL does not have types (every identifier holds one or multiple bits which are either 0 or 1) I am ignoring this step here.</p>
</aside>

<p>In this post we will tackle the lexical analysis of HDL starting with describing the <i>lexical syntax</i>.</p>

<h2>The Lexical Syntax of HDL</h2>

<p>Let’s have a first glimpse at an HDL script:</p>

[code language="nand2tetris-hdl"]
/**
 * Checks if two input bits are equal
 */

CHIP Eq {
  IN a, b;
  OUT out; // True iff a=b
  PARTS:
    Xor(a=a, b=b, out=uneq);
    Not(in=uneq, out=out);
}
[/code]

<p>I can see things like identifiers (<code>a</code>, <code>b</code>, …), single and multi line comments, reserved words (<code>CHIP</code>, <code>IN</code>, …), and symbols (<code>{</code>, <code>}</code>, <code>;</code>, …). Based on the HDL primer inside the book <a href="https://www.nand2tetris.org/book">The Elements of Computing Systems</a> (the book accompanying the online course I mentioned in the intro of this article) I came up with the following grammar describing the lexical syntax of HDL.</p>

<aside>
  <p>The lexical syntax describes how tokens are created out of characters and symbols and is the first part of the concrete syntax. The other half is called <i>phrasal syntaxt</i> that describes how phrases are made out of tokens. We will talk more about phrasal syntax in part two of this series.</p>
</aside>

[code language="html"]
   token = "CHIP" | "IN" | "OUT" | "PARTS" | "true" | "false" | "(" | ")" | "{" | "}" | "[" | "]" | "=" | ":" | ";" | "," | ".." | num | id
     num = digit [ num ]
      id = letter [ alphanum ]
alphanum = ( digit | letter ) [ alphanum ]
  letter = "a" | … | "z" | "A" | … | "Z"
   digit = "0" | … | "9"
[/code]

<p>That means a token is either one of the reserved words, a certain symbol, a number, or an identifier. An identifier is any sequence of letters and digits not starting with a digit. HDL is case sensitive so I included lowercase and uppercase letters.</p>

<aside>
  <p>You might ask yourself why I didn’t include the comment symbols <code>//</code>, <code>/**</code>, and <code>*/</code> in the list of tokens. Comments will be ignored by our interpreter and do not have to be part of our stream of tokens, just like whitespace (spaces, tabs, and line breaks),</p>
</aside>

<p>This simple <code>token</code> rule of the grammar above can now be transformed one-to-one into Reason code using a <i>variant</i>:</p>

[code language="reason"]
type token =
  | CHIP | IN | OUT | PARTS
  | TRUE | FALSE
  | LPAR | RPAR | LBRACE | RBRACE | LBRACK | RBRACK | EQUAL | COLON | SEMIC | COMMA | DDOT
  | NUM(int)
  | ID(string)
[/code]

<p>Isn’t this gorgeous? <code>token</code> is a variant with a number of so-called <i>constructors</i>. A variant is a very elegant way to say that a token can either be this or that or that other thing. Constructors can even hold extra data, like <code>NUM</code> (holding an <code>int</code> value) and <code>ID</code> (holding the identifier <code>string</code>).</p>

<p>Now that we defined the lexical syntax and introduced a <code>token</code> variant, we can move on to implementing the actual <code>lex</code> function that takes our code and transforms it into a list of tokens.</p>

<h2>Implementing the Lexer</h2>

<p>Let’s recap our plan: We want to write a function that takes our code as a <code>string</code>, traverses it character by character and spits out a list of tokens. Unfortunately, a <code>string</code> in Reason is not a list of <code>char</code>s (unlike in Standard ML). So we have to write a little helper function that does that for us.</p>

[code language="reason"]
let explode = (s) => {
  let rec exp = (cs, i) => i < 0 ? cs : exp([s.[i], ...cs], i - 1);
  exp([], String.length(s) - 1)
}
[/code]

<aside>
  <p>Please note that function <code>exp</code> is tail recursive and uses an accumulator parameter to keep track of the list of characters and a wrapper function <code>explode</code> to hide this implementation detail. This is a pattern you will see frequently in functional programming. Feel free to visit my <a href="https://sketch.sh/s/AEnu2UbVgRrTTC0FRpExw9/">Reason sketch</a> to learn more about tail recursion and why it is important.</p>
</aside>

<p>I also introduce some helper functions to check whether a character is a digit, a letter, or alphanumerical (digit or letter). Finally, I declare an exception which is raised if we come across an unknown character.</p>

[code language="reason"]
exception InvalidCharacter(char)

let isDigit = (c) => Char.code(c) >= 48 && Char.code(c) <= 57

let isLetter = (c) => {
  let lowercaseC = Char.lowercase(c);
  Char.code(lowercaseC) >= 97 && Char.code(lowercaseC) <= 122
}

let isAlphaNum = (c) => isLetter(c) || isDigit(c)
[/code]

<p>All that’s left to do now is implementing the actual <code>lex</code> function. This is the moment where Reason really shines and offers us two amazing features—<i>pattern matching</i> and <i>mutually recursive functions</i>—to produce concise and readable code.</p>

[code language="reason"]
let rec lex = (cs) =>
  switch (cs) {
    | [] => []
    | [' ' | '\n' | '\r' | '\t', ...cr] => lex(cr)
    | ['C', 'H', 'I', 'P', ...cr] => [CHIP, ...lex(cr)]
    | ['I', 'N', ...cr] => [IN, ...lex(cr)]
    | ['O', 'U', 'T', ...cr] => [OUT, ...lex(cr)]
    | ['P', 'A', 'R', 'T', 'S', ...cr] => [PARTS, ...lex(cr)]
    | ['t', 'r', 'u', 'e', ...cr] => [TRUE, ...lex(cr)]
    | ['f', 'a', 'l', 's', 'e', ...cr] => [FALSE, ...lex(cr)]
    | ['(', ...cr] => [LPAR, ...lex(cr)]
    | [')', ...cr] => [RPAR, ...lex(cr)]
    | ['{', ...cr] => [LBRACE, ...lex(cr)]
    | ['}', ...cr] => [RBRACE, ...lex(cr)]
    | ['[', ...cr] => [LBRACK, ...lex(cr)]
    | [']', ...cr] => [RBRACK, ...lex(cr)]
    | ['=', ...cr] => [EQUAL, ...lex(cr)]
    | [':', ...cr] => [COLON, ...lex(cr)]
    | [';', ...cr] => [SEMIC, ...lex(cr)]
    | [',', ...cr] => [COMMA, ...lex(cr)]
    | ['.', '.', ...cr] => [DDOT, ...lex(cr)]
    | ['/', '/', ...cr] => lexCommLine(cr)
    | ['/', '*', ...cr] => lexCommBlock(cr)
    | [c, ...cr] => if (isDigit(c)) {
        lexNum(0, [c, ...cr])
      }
      else if (isLetter(c)) {
        lexId("", [c, ...cr])
      }
      else {
        raise(InvalidCharacter(c))
      }
  }
and lexNum = (v, cs) => if (List.length(cs) == 0 || !isDigit(List.hd(cs))) {
    [NUM(v), ...lex(cs)]
  }
  else {
    lexNum(10 * v + Char.code(List.hd(cs)) - Char.code('0'), List.tl(cs)) /* A */
  }
and lexId = (v, cs) => if (List.length(cs) == 0 || !isLetterNum(List.hd(cs))) {
    [ID(v), ...lex(cs)]
  }
  else {
    lexId(v ++ String.make(1, List.hd(cs)), List.tl(cs))
  }
and lexCommLine = (cs) => if (List.hd(cs) == '\n') {
    lex(List.tl(cs))
  }
  else {
    lexCommLine(List.tl(cs))
  }
and lexCommBlock = (cs) => if (List.hd(cs) == '*' && List.hd(List.tl(cs)) == '/') { /* B */
    lex(List.tl(List.tl(cs)))
  }
  else {
    lexCommBlock(List.tl(cs))
  }
[/code]

<p>If <code>cs</code> (the source code as a list of characters) is empty we return the empty list and are done. If the first element (or <i>head</i>) of the character list is whitespace we ignore it and move on. If the characters match any of the reserved words or special symbols of HDL we consume those characters, append the respective token to our list, and move on.</p>

<p>Comments, numbers, and identifiers are a bit trickier and need some extra care. I call helper lexers in case we detect a number, letter, or comment symbol. The functions <code>lexCommLine</code> and <code>lexCommBlock</code> use look-ahead to detect whether the comment has ended. <code>lexNum</code> and <code>lexId</code> use the helper functions introduced earlier to return the variant constructors <code>NUM</code> and <code>ID</code>, respectively. <code>NUM</code> carries the <code>int</code> value of the number and <code>ID</code> the <code>string</code> value of the identifier. Once the helper lexers are done with their work, we can call <code>lex</code> to carry on with the main task, thanks to mutually recursive functions (aka the <code>and</code> syntax).</p>

<p>Let me just highlight a couple of details:</p>

<ul>
  <li>The expression <code>[CHIP, ...lex(cr)]</code> evaluates to a new list containing the <code>CHIP</code> token as the first element and all elements of the list that the call <code>lex(cr)</code> returns appended to the end. Reason’s syntax is based on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">JavaScript’s spread operator</a>, in other languages it might be <code>CHIP::lex(cr)</code> or <code>cons(CHIP, lex(cr))</code>.</li>
  <li>In line <code>A</code> I use the expression <code>10 * v + Char.code(List.hd(cs)) - Char.code('0')</code> to calculate the integer value of a sequence of characters. <code>Char.code</code> gives us the ASCII code of a character and can therefore be used to convert a character into a digit by subtracting the ASCII code of 0, the first digit in the <a href="https://en.wikipedia.org/wiki/ASCII">ASCII table</a>.</li>
  <li>Line <code>B</code> heavily uses list methods like <code>hd</code> (head, the first element of a list) and <code>tl</code> (tail, the list without the first element). This is necessary because lists in Reason, unlike arrays, are single-linked and do not allow random access.</li>
</ul>

<aside>
  <p>The <code>lex</code> function is not tail recursive. I made this decision in favor of readability and simplicity and will leave it to you as an exercise to make <code>lex</code> tail recursive. Hint: You will need an accumulator and <code>List.rev</code>.</p>
</aside>

<p>And there you have it, our lexer is done! You can play around with a <a href="https://sketch.sh/s/dCdG9McVlz4qJzEFixGiNv/">working version on Sketch.sh</a> that also includes a wrapper called <code>lexer</code> which takes care of splitting up our code string and calling <code>lex</code>.</p>
